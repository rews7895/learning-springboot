# 참고사항
1. spring actuator: 애플리케이션의 모니터링 및 관리 도구

### 스프링부트는 내장 WAS가 존재한다.
1. 톰캣
2. 제티
3. 언더토우

### 제어의 역전 (IoC, Inversion of Control)
- 제어의 역전은 다른 객체를 직접 생성하거나 제어하는 것이 아니라 외부에서 관리하는 객체를 가져와 사용하는 것
- 객체의 생성과 관리를 개발자가 하는 것이 아니라 프레임워크가 대신하는 것

### 의존성 주입 (DI, Dependency Injection)
- 외부에서 객체를 주입받아 사용하는 것
- 제어의 역전을 구현하기 위해 DI를 사용한다.

### 스프링 컨테이너
- 빈을 생성하고 관리한다.
- 즉, 빈이 생성되고 소멸되기까지의 생명주기를 이 스프링 컨테이너가 관리하며 @Autowired 같은 어노테이션을 사용해 빈을 주입받을 수 있게 DI를 지원하기도 한다.

### 빈
- 스피링 컨테이너가 생성하고 관리하는 객체
- 스프링은 빈을 스프링 컨테이너에 등록하기 위해 XML 파일 설정, 어노테이션 추가등의 여러가지 방법을 제공한다.

### 관점 지향 프로그래밍 (AOP, Aspect Oriented Programming)
- 프로그래밍에 대한 관심을 핵심 관점, 부가 관점으로 나누어서 관심 기준으로 모듈화하는 것을 의미

### 이식 가능한 서비스 추상화 (PSA, Portable Service Abstraction)
- 스프링에서 제공하는 다양한 기술들을 추상화해 개발자가 쉽게 사용하는 인터페이스
- 어느 기술을 사용하던 일관된 방식으로 처리하도록 하는 것

### 스프링 부트 스타터
- spring-boot-stater-{작업유형}이라는 명명 규칙 존재
- spring-boot-stater-web: Spring MVC를 사용해서 RESTful 웹 서비스를 개발할 때 필요한 의존성 모음
- spring-boot-stater-test: 스프링 애플리케이션을 테스트하기 위해 필요한 의존성 모음
- spring-boot-stater-validation: 유효성 검사를 위해 필요한 의존성 모음
- spring-boot-actuator: 모니터링을 위해 애플리케이션에서 제공하는 다양한 정보를 제공하기 쉽게 하는 의존성 모음
- spring-boot-stater-data-jpa: ORM을 사용하기 위한 인터페이스의 모음인 JPA를 더 쉽게 사용하기 위한 의존성 모음

### 어노테이션
- 자바 소스 코드에 추가하는 표식으로, 보통 @ 기호를 앞에 붙여서 사용하며, JDK 1.5 버전부터 사용할 수 있다.
- 어노테이션은 다양한 목적으로 사용하지만, 메타 데이터(데이터에 대한 설명을 담고 있는 데이터)의 비중이 가장 크다.

### 자주 볼 수 있는 어노테이션 정리
- @SpringBootApplication: 스프링 부트 사용에 필요한 기본 설정을 해준다.
- @SpringBootConfiguration: 스프링 부트 관련 설정을 나타내는 어노테이션이며 스프링의 @Configuration을 상속해서 만듬.
- @ComponentScan: 사용자가 등록한 빈을 읽고 등록하는 어노테이션
- @EnableAutoConfiguration: 자동 구성을 활성화하는 어노테이션이며, 스프링 부트 서버가 실행될 때 스프링 부트의 메타파일을 읽고 정의된 설정들을 자동으로 구성하는 역할을 수행
- @Configuration: 설정 파일 등록
- @Repository: ORM 매핑
- @Controller, @RestController: 라우터
- @Service: 비즈니스 로직
- @SpringBootConfig: 스프링 부트 관련 설정
- @Component: 해당 어노테이션은 빈으로 등록되며, @Controller, @RestController, @Configuration, @Repository, @Service 모두 @Component 어노테이션을 가지고 있으며, 상황에 따라 알맞은 어노테이션을 사용해야 한다.
- @Entity: 엔티티로 지정
- @Id: id 필드를 기본키로 지정
- @GeneratedValue(starategy = GenerationType.IDENTITY): 기본키를 자동으로 1씩 증가
- @Builder: 빌터 패턴으로 객체 생성
- @AllArgsConstructor: 모든 필드 값을 파라미터로 받는 생성자 추가
- @NoArgsConstructor: 기본 생성자를 추가해준다
- @NoArgsConstructor(access = AccessLevel.PROTECTED): 접근 제어자가 protected인 기본 생성자를 만들어준다.
- @Getter: 모든 필드에 접근자 메서드를 만들어준다.
- @PathVariable: URL에서 값을 가져오는 어노테이션
- @Transactional: 매칭한 매서드를 하나의 트랜잭션으로 묶는 역할을 한다.
- @EnableJpaAuditing: JPA 엔티티 자동 업데이트
- @ConfigurationProperties: 자바 클래스에 프로퍼티값을 가져와서 사용하는 어노테이션

### 스프링 부트 계층구조
- 프레젠테이션 계층: HTTP 요청을 받고 이 요청을 비즈니스 계층으로 전송하는 역할을 하며, 컨트롤러가 프레젠테이션 계층의 역할을 한다.
- 비즈니스 계층: 모든 비즈니스 로직을 처리하며, 비즈니스 로직이란 서비스를 만들기 위한 로직을 말한다.
- 퍼시스턴트 계층: 모든 데이터베이스 관련 로직을 처리한다. 이 과정에서 데이터베이스에 접근하는 DAO 객체를 사용할 수 있다. DAO는 데이터베이스 계층과 상호작용하기 위한 객체이며, 리포지토리가 퍼시스턴스 계층의 역할을 한다.

### 추천 프로젝트 구조
- main: 실제 코드를 작성하는 공간이며, 프로젝트 실행에 필요한 소스코드나 리소스 파일은 모두 이 폴더 안에 들어있다.
- test: 프로젝트의 소스 코드를 테스트할 목적의 코드나 리소스 파일이 들어 있다.
- build.gradle: 빌드를 설정하는 파일로 의존성이나 플러그인 설정 등과 같이 빌드에 필요한 설정을 할 때 사용한다.
- settings.gradle: 빌드할 프로젝트의 정보를 설정하는 파일이다.
- main/resources/templates: HTML과 같은 뷰 관련 파일을 담는 공간이다.
- main/resources/static: JS, CSS, 이미지와 같은 정적 파일을 담는 공간이다.
- main/resources/application.yml: 스프링 부트의 데이터베이스의 설정 정보, 로깅 설정 정보 등이 들어갈 수도 있고, 직접 설정을 정의할 때 사용하기도 한다. 또한 스프링 부트 서버가 실행되면 자동으로 로딩되는 파일이다.
- main/resources/data.sql: 미리 생성할 데이터 관련 쿼리
- main/java/[DOMAIN]/controller/*: 컨트롤러를 담는 공간
- main/java/[DOMAIN]/domain/*: 도메인을 담는 공간
- main/java/[DOMAIN]/dto/*: 계층끼리 데이터를 교환하기 위해 사용하는 객체를 담을 공간
- main/java/[DOMAIN]/repository/*: 리포지토리 인터페이스를 담을 공간
- main/java/[DOMAIN]/service/*: 서비스 로직을 담을 공간

### 디스패처 서블릿
- URL을 분석하고, 이 요청을 처리할 수 있는 컨트롤러를 찾아준다.

## 4장.

### 테스트 코드 작성
- given-when-then 패턴: 테스트 코드를 세 단계로 구분해 작성하는 방식
- given: 테스트 실행을 준비하는 단계
- when: 테스트를 진행하는 단계
- then: 테스트 결과를 검증하는 단계

### 스프링 부트 스타터 테스트 목록
- JUnit: 자바 프로그래밍 언어용 단위 테스트 프레임워크
- AssertJ: 검증문인 어설션을 작성하는데 사용되는 사용되는 라이브러리
- Spring Test & Spring Boot Test: 스프링 부트 애플리케이션을 위한 통합 테스트 지원
- Hamcrest: 표현식을 이해하기 쉽게 만드는데 사용되는 Matcher 라이브러리
- Mockito: 테스트에 사용할 가짜 객체인 목 객체를 쉽게 만들고, 관리하고, 검증할 수 있게 지원하는 테스트 프레임워크
- JSONassert: JSON용 어설션 라이브러리
- JsonPath: JSON 데이터에서 특정 데이터를 선택하고 검색하기 위한 라이브러리

### JUnit
- 단위 테스트 프레임워크
- 테스트 방식을 구분할 수 있는 어노테이션을 제공
- @Test 어노테이션으로 메서드를 호출할 때마다 새 인스턴스를 생성, 독립 테스트 가능
- 예상 결과를 검증하는 어설션 메서드 제공
- 사용 방법이 단순, 테스트 코드 작성 시간이 적음
- 자동 실행, 자체 결과를 확인하고 즉각적인 피드백을 제공

### 뷰 리졸버
- 템플릿 엔진을 사용해 HTML 문서를 만들거나 JSON, XML 등의 데이터를 생성합니다.

### JUnit 테스트 어노테이션
- @BeforeAll: 전체 테스트를 시작하기 전에 처음으로 한 번만 실행한다. 예를 들어 데이터베이스를 연결해야 하거나 테스트 환경을 초기화할 때 사용되며, 전체 테스트 실행 주기에서 한 번만 호출되어야 하기 때문에 메서드를 static으로 선언해야 한다.
- @BeforeEach: 테스트 케이스를 시작하기 전에 매번 실행한다. 예를 들어 테스트 메서드에서 사용하는 객체를 초기화하거나 테스트에 필요한 값을 미리 넣을 때 사용할 수 있다. 
- @AfterAll: 전체 테스트를 마치고 종료하기 전에 한 번말 실행한다. 예를 들어 데이터베이스 연결을 종료할 때나 공통적으로 사용하는 지원을 해제할 때 사용할 수 있다. 전체 테스트 실행 주기에서 한 번만 호출되어야 하므로 메서드를 static으로 선언해야 한다.  
- @AfterEach: 각 테스트 케이스를 종료하기 전 매번 실행한다. 예를 들어 테스트 이후에 특정 데이터를 삭제해야 하는 경우 사용한다.

### AssertJ
- JUnit과 함께 사용해 검증문의 가독성을 높여주는 라이브러리
- isEqualTo(A): A값과 같은지 검증
- isNotEqualTo(A): A값과 다른지 검증
- contains(A): A값을 포함하는지 검증
- doesNotContain(A): A값을 포함하지 않는지 검증
- startsWith(A): 접두사가 A인지 검증
- endsWith(A): 점미사가 A인지 검증
- isEmpty(): 비어 있는 값인지 검증
- isNotEmpty(): 비어 있지 않은 값인지 검증
- isPositive(): 양수인지 검증
- isNegative(): 음수인지 검증
- isGreaterThan(1): 1보다 큰 값인지 검증
- isLessThan(1): 1보다 작은 값인지 검증

### AssertJ 관련 어노테이션
- @SpringBootTest: 메인 어플리케이션 클래스에 추가하는 어노테이션인 @SpringBootApplication이 있는 클래스를 찾고 그 클래스에 포함되어 있는 빈을 찾은 다음 테스트용 어플리케이션 컨텍스트라는 것을 만든다.
- @AutoConfigureMockMvc: MockMvc를 생성하고 자동으로 구성하는 어노테이션이다. MockMvc는 어플리케이션을 서버에 배포하지 않고도 테스트용 MVC 환경을 만들어 요청 및 전송, 응답 기능을 제공하는 유틸리티 클래스이다. 즉, 컨트롤러를 테스트할 때 사용되는 클래스이다.

## 5장.

### ORM (Object-relational mapping)
- 자바의 객체와 데이터베이스를 연결하는 프로그래밍 기법
- 자바에서는 JPA (Java Persistence API)가 ORM의 표준
- 하이버네이트는 JPA 인터페이스를 구현한 구현체이자 자바용 ORM 프레임워크이며, 내부적으로는 JDBC API를 사용한다.
- 하이버네이트의 목표는 자바 객체를 통해 데이터베이스 종류에 상관없이 데이터베이스를 자유자재로 사용할 수 있게 하는 것이다.
- ORM의 장점
  1) SQL을 직접 작성하지 않고 사용하는 언어로 데이터베이스에 접근할 수 있다.
  2) 객체지향적으로 코드를 작성하르 수 있기 때문에 비즈니스 로직에만 집중할 수 있다.
  3) 데이터베이스 시스템이 추상화되어 있기 때문에 MySQL에서 PostgreSQL로 전환한다고 해도 추가로 드는 작업이 거의 없습니다. 즉 데이터베이스 시스템에 대한 종속성이 줄어듭니다.
  4) 매핑하는 정보가 명확하기 때문에 ERD에 대한 의존도를 낮출 수 있고 유지보수할 때 유리합니다.
- ORM의 단점
  1) 프로젝트의 복잡성이 커질수록 사용 난이도도 올라갑니다.
  2) 복잡하고 무거운 쿼리는 ORM으로 해결이 불가능한 경우가 있습니다.

### 엔티티 매니저
- entity (엔티티): 데이터베이스의 테이블과 매핑되는 객체를 의미.
- entity amnager (엔티티 매니저): 엔티티를 관리해 데이터베이스와 애플리케이션 사이에서 객체를 생성, 수정, 삭제하는 등의 역할을 한다. 
- 이러한 엔티티 매니저를 만드는 곳이 entity manager factory (엔티티 매니저 팩토리)이다.

### 영속성 컨텍스트
- JPA의 중요한 특징 중 하나로, 엔티티를 관리하는 가상의 공간이다.
- 영속성 컨텍스트 때문에 데이터 베이스에서 효과적으로 데이터를 가져올 수 있고, 엔티티를 편하게 사용할 수 있는 것이다.
- 1차 캐시, 쓰기 지연, 변경 감지, 지연 로딩이라는 특징이 있다.
- 1차 캐시
  1) 캐시의 키는 @Id 어노테이션이 달린 기본키 역할을 하는 식별자이며 값은 엔티티이다. 엔티티를 조회하면 1차 캐시에서 데이터를 조회하고 값이 있으면 반환, 없으면 데이터베이스에서 조회해 1차 캐시에 저장한 다음 반환한다. 캐시된 데이터를 조회할 때에는 데이터베이스를 거치지 않아도 되므로 매우 빠르게 데이터를 조회할 수 있다.
- 쓰기 지연 (transactional write-behind)
  1) 트랜잭션을 커밋하기 전까지는 데이터베이스에 실제로 질의문을 보내지 않고 쿼리를 모았다가 트랜잭션을 커밋하면 모았던 쿼리를 한번에 실행하는 것을 의미한다.
- 변경 감지
  1) 트랜잭션을 커밋하면 1차 캐시에 저장되어 있는 엔티티의 값과 현재 엔티티의 값을 비교해서 변경된 값이 있다면 변경 사항을 감지해 변경된 값을 데이터베이스에 자동으로 반영한다.
- 지연 로딩 (lazy loading)
  1) 쿼리로 요청한 데이터를 애플리케이션에 바로 로딩하는 것이 아니라 필요할 때 쿼리를 날려 데이터를 조회하는 것을 의미한다.
- 해당 특징들은 모두 데이터베이스의 접근을 최소화해 성능을 높일 수 있다.

### 엔티티의 상태
- 엔티티는 4가지 상태를 가진다.
- 분리 (detached) 상태: 영속성 컨텍스트가 관리하고 있지 않는 상태
- 관리 (managed) 상태: 영속성 컨텍스트가 관리하는 상태
- 비영속 (transient) 상태: 영속성 컨텍스트와 전혀 관계가 없는 상태
- 삭제된 (removed) 상태

### @GeneratedValue 의 자동키 설정 방식
- AUTO: 선택한 데이터베이스 방언(dialect)에 따라 방식을 자동으로 선택(기본값)
- IDENTITY: 기본키 생성을 데이터베이스에 위임(=AUTO_INCREMENT)
- SEQUENCE: 데이터베이스 시퀀스를 사용해서 기본키를 할당하는 방법. 오라클에서 주로 사용 
- TABLE: 키 생성 테이블 사용

### @Column 어노테이션의 속성
- name: 필드와 매핑할 컬럼 이름. 설정하지 않으면 필드 이름으로 지정해준다.
- nullable: 컬럼의 null 허용 여부. 설정하지 않으면 true(nullable)
- unique: 컬럼의 유일한 값(unique) 여부. 설정하지 않으면 false(non unique)
- columnDefinition: 컬럼 정보 설정. default 값을 줄 수 있다.

### REST (Representational State Transfer)
- URL 설계 방식
- 자원을 이름으로 구분해 자원의 상태를 주고받는 API 방식
- 특징
  1) 서버 / 클라이언트 구조, 무상태, 캐시 처리 가능, 계층화, 인터페이스 일관성과 같은 특징이 있다.
- 장점
  1) URL만 보고도 무슨 행동을 하는 API인지 명확하게 알 수 있다.
  2) 상태가 없다는 특징이 있어서 클라이언트와 서버의 역할이 명확하게 분리된다.
  3) HTTP 표준을 사용하는 모든 플랫폼에서 사용할 수 있다.
- 단점
  1) HTTP 메서드, 즉 GET, POST와 같은 방식의 개수에 제한이 있고, 설계를 하기 위해 공식적으로 제공되는 표준 규약이 없다는 것이다.
- REST API는 주소와 메서드만 보고 요청의 내용을 파악할 수 있다는 강력한 장점이 있어 많은 개발자가 사용한다.
- REST하게 디자인한 API를 RESTful API라 부르기도 한다.
- REST API를 사용하는 방법
  1) URL에는 동사를 쓰지 말고, 자원을 표시해야 한다.
  2) 동사는 HTTP 메서드로

### 응답코드
- 200 OK: 요청이 성공적으로 수행되었음
- 201 Created: 요청이 성공적으로 수행되었고, 새로운 리소스가 생성되었음
- 400 Bad Request: 요청 값이 잘못되어 요청에 실패했음
- 403 Forbidden: 권한이 없어 요청에 실패했음
- 404 Not Found: 요청 값으로 찾은 리소스가 없어 요청에 실패했음
- 500 Internal Server Error: 서버 상에 문제가 있어 요청에 실패했음

### 테스트 코드 작성 이유
- 테스트 코드를 작성하면 코드의 기능이 제대로 작동한다는 것을 검증할 수 있다.

